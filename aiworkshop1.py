# -*- coding: utf-8 -*-
"""aiworkshop1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_4c4U-BLK5YYTzLq3CbtiJyheyCfzTs0
"""

from google.colab import drive
drive.mount('/content/drive')

"""#2.1 Exercise - 1:"""

from PIL import Image
image =Image.open("/content/drive/MyDrive/Lenna_(test_image).png")
display(image)

import numpy as np

image_array= np.array(image)
print (" Shape of the image array :", image_array.shape)

3 # Crop the image
cropped_image = image_array [:100,:100]
5 # Display the cropped image
display ( cropped_image )

red_channel = image_array[: , : , 0] # Red channel
print ( red_channel )
display ( red_channel )
# For Green Channels
green_channel = image_array[: , : , 1] # Green

print ( green_channel )
display ( green_channel )
blue_channel = image_array [: , : , 2] # Blue channel
print ( blue_channel )
display ( blue_channel )

image_array[:100,:100]=210
display(image_array)



"""#2.2 Exercise - 2:

1. Load and display a grayscale image.
"""

#Load a grayscale image using the Pillow library.
from PIL import Image
import matplotlib.pyplot as plt
#Fetch an image of you choice.{If colour convert to grayscale}
image=Image.open("/content/drive/MyDrive/Lenna_(test_image).png").convert("L")
image_array=np.array(image)


# Display the image
plt.imshow(image_array, cmap='gray')
plt.title("Original Grayscale Image")
plt.show()

# Extract and display the middle section (150 pixels)
width, height = image_gray.size
start_y = (height - 150) // 2
cropped_image = image_gray.crop((0, start_y, width, start_y + 150))
plt.imshow(cropped_image)
plt.title("Cropped Section")

# Apply a threshold
image_array = np.array(image_gray)
threshold_image = np.where(image_array < 100, 0, 255).astype(np.uint8)

plt.imshow(threshold_image)
plt.title("Binary Image")

# Rotate the image 90 degrees clockwise
rotated_image = image_gray.rotate(-90)
plt.imshow(rotated_image)
plt.title("Rotated 90Â°")

# Convert grayscale to RGB
rgb_image = np.stack((image_array,)*3, axis=-1)  # Replicate grayscale values across RGB channels
rgb_image = Image.fromarray(rgb_image)
plt.imshow(rgb_image)
plt.title("RGB Image")

"""#2.3 Exercise - 3:

1. 1. Load and Prepare Data:
"""

# Read the image using the Pillow library and display it.
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
#Fetch an image of you choice.{If colour convert to grayscale}
image=Image.open("/content/drive/MyDrive/Lenna_(test_image).png").convert("L")
#convert to numpy array
image = np.array(image)
display(image_gray)

# Standardize the data
mean = np.mean(image, axis=0)
std = np.std(image, axis=0)
standardized_data = (image - mean) / std

# Compute covariance matrix
cov_matrix = np.cov(standardized_data, rowvar=False)
print(cov_matrix)

"""2. Eigen Decomposition and Identifying Principal Components:"""

# Compute Eigenvalues and Eigenvectors
eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)

# Sort eigenvalues in descending order
sorted_indices = np.argsort(eigenvalues)[::-1]
eigenvalues = eigenvalues[sorted_indices]
eigenvectors = eigenvectors[:, sorted_indices]

# Identify Principal Components with cumulative sum plot
plt.figure(figsize=(8, 5))
plt.plot(np.cumsum(eigenvalues) / np.sum(eigenvalues))
plt.xlabel("Number of Principal Components")
plt.ylabel("Cumulative Explained Variance")
plt.title("Explained Variance vs. Number of Components")
plt.grid()
plt.show()

# Output Eigenvalues
print(eigenvalues)

#3
# Function to reconstruct image with given number of components
def reconstruct_image(k, eigenvectors, image_standardized, mean, std):
    top_k_eigenvectors = eigenvectors[:, :k]
    image_reduced = np.dot(image_standardized, top_k_eigenvectors)
    image_reconstructed = np.dot(image_reduced, top_k_eigenvectors.T)
    return (image_reconstructed * std) + mean

# Experiment with different k values
k_values = [10, 50, 100, 150]
plt.figure(figsize=(12, 8))

for i, k_val in enumerate(k_values):
    reconstructed_image = reconstruct_image(k_val, eigenvectors, standardized_data, mean, std)
    plt.subplot(2, 2, i + 1)
    plt.imshow(reconstructed_image, cmap="gray")
    plt.title(f"k = {k_val}")
    plt.axis("off")

plt.tight_layout()
plt.show()